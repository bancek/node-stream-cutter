// Generated by CoffeeScript 1.6.3
(function() {
  var Duplex, StreamCutter, stream, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  stream = require('stream');

  Duplex = (function(_super) {
    __extends(Duplex, _super);

    function Duplex() {
      _ref = Duplex.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    Duplex.prototype._transform = function(chunk, encoding, cb) {
      this.push(chunk);
      return cb();
    };

    return Duplex;

  })(stream.Transform);

  StreamCutter = (function(_super) {
    __extends(StreamCutter, _super);

    function StreamCutter(chunkSize) {
      this.nextStream = __bind(this.nextStream, this);
      this.read = __bind(this.read, this);
      this._transform = __bind(this._transform, this);
      this._endCurrentStream = __bind(this._endCurrentStream, this);
      this._createNextStream = __bind(this._createNextStream, this);
      var _this = this;
      StreamCutter.__super__.constructor.call(this);
      this.chunkSize = chunkSize;
      this.done = false;
      this.remainder = null;
      this.currentStream = null;
      this.error = null;
      this.on('end', function() {
        _this.done = true;
        if (_this._readableState.buffer.length === 0 && !_this.remainder) {
          return _this._endCurrentStream();
        }
      });
      this.on('error', function(err) {
        if (_this.currentStream) {
          return _this.currentStream.emit('error', err);
        } else {
          return _this.error = err;
        }
      });
    }

    StreamCutter.prototype._createNextStream = function() {
      var err,
        _this = this;
      this.currentStream = new Duplex();
      this.currentRead = 0;
      this.pipe(this.currentStream, {
        end: false
      });
      if (this.error != null) {
        err = this.error;
        this.error = null;
        return process.nextTick(function() {
          var _ref1;
          return (_ref1 = _this.currentStream) != null ? _ref1.emit('error', err) : void 0;
        });
      }
    };

    StreamCutter.prototype._endCurrentStream = function() {
      var _this = this;
      return process.nextTick(function() {
        var currentStream;
        if (_this.currentStream != null) {
          currentStream = _this.currentStream;
          _this.currentStream = null;
          currentStream.end();
          return _this.unpipe();
        }
      }, 0);
    };

    StreamCutter.prototype._transform = function(chunk, encoding, done) {
      this.push(chunk);
      return done();
    };

    StreamCutter.prototype.read = function(size) {
      var accepted, acceptedLen, data, len,
        _this = this;
      if (this.done && (this.remainder == null)) {
        this._endCurrentStream();
        return null;
      }
      if (this.currentStream == null) {
        return null;
      }
      if (size === 0) {
        return new Buffer(0);
      }
      if (this.currentRead === this.chunkSize) {
        return null;
      }
      if (this.remainder != null) {
        data = this.remainder;
        this.remainder = null;
      } else {
        data = StreamCutter.__super__.read.apply(this, arguments);
      }
      if (data == null) {
        return null;
      }
      len = data.length;
      if (this.currentRead + len < this.chunkSize) {
        this.currentRead += len;
        if (this.done) {
          this._endCurrentStream();
        }
        return data;
      } else {
        acceptedLen = this.chunkSize - this.currentRead;
        accepted = data.slice(0, acceptedLen);
        this.currentRead = this.chunkSize;
        this.remainder = data.slice(acceptedLen);
        process.nextTick(function() {
          return _this._endCurrentStream();
        });
        return accepted;
      }
    };

    StreamCutter.prototype.nextStream = function() {
      if (!this.done || (this.remainder != null)) {
        this._createNextStream();
        return this.currentStream;
      } else {
        return null;
      }
    };

    return StreamCutter;

  })(stream.Transform);

  module.exports = StreamCutter;

}).call(this);
